{"version":3,"file":"index.js","sources":["../lib/constants.js","../lib/position.js","../lib/unit-converter.js"],"sourcesContent":["'use strict'\n\nexport const USFT_TO_METERS = 1200 / 3937\nexport const USYD_TO_METERS = USFT_TO_METERS * 3\n","'use strict'\n\nconst dmsToDeg = (deg, min, sec) => {\n  if (deg && min && sec) {\n    return deg + min / 60 + sec / 3600\n  } else {\n    var parts = deg.split(' ').map(function (n) {\n      return parseFloat(n)\n    })\n    return parts[0] + parts[1] / 60 + parts[2] / 3600\n  }\n}\n\n/**\n * transformPoint - Apply tranformation matrix to a point\n *\n * @param {array} matrix the transformation matrix\n * @param {array} point  [x, y, z]\n * @return {array} [x, y, z]\n */\nconst transformPoint = (matrix, point) => {\n  const x =\n    matrix[0][0] * point[0] +\n    matrix[0][1] * point[1] +\n    matrix[0][2] * point[2] +\n    matrix[0][3] * 1\n  const y =\n    matrix[1][0] * point[0] +\n    matrix[1][1] * point[1] +\n    matrix[1][2] * point[2] +\n    matrix[1][3] * 1\n  const z =\n    matrix[2][0] * point[0] +\n    matrix[2][1] * point[1] +\n    matrix[2][2] * point[2] +\n    matrix[2][3] * 1\n  return { x, y, z }\n}\n\nconst getZone = (lat, lon) => {\n  if (!(lat >= -80 && lat <= 84)) throw new Error('Outside UTM limits')\n\n  const zone = Math.floor((lon + 180) / 6) + 1 // longitudinal zone\n\n  if (lat < 0) return `${zone}S`\n  return `${zone}N`\n}\n\nconst getProj4FromZone = zone => {\n  const isSouth = zone.substr(-1, 1).toLowerCase() === 's'\n\n  if (zone < 1 || zone > 60) {\n    throw new Error('UTM zone invalid')\n  }\n\n  if (isSouth) {\n    return `+proj=utm +zone=${zone} +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs`\n  } else {\n    return `+proj=utm +zone=${zone} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`\n  }\n}\n\n/**\n * Returns the WGS84 UTM Zone EPSG code for a give latlon\n * @see http://gis.stackexchange.com/questions/33219/how-to-convert-lat-long-to-utm-using-proj4j-similar-to-jscience-utm-latlongtou\n */\nconst getEPSGCodeFromCoords = (lat, lon) => {\n  const zone = getZone(lat, lon)\n  const zoneNum = +zone.replace('N', '').replace('S', '')\n\n  if (zone.indexOf('S') !== -1) {\n    return `EPSG:${32700 + zoneNum}`\n  }\n  return `EPSG:${32600 + zoneNum}`\n}\n\nconst getEPSGCodeFromZone = zone => {\n  const zoneNum = +zone.replace('N', '').replace('S', '')\n  if (zone.indexOf('S') !== -1) {\n    return `EPSG:${32700 + zoneNum}`\n  }\n  return `EPSG:${32600 + zoneNum}`\n}\n\nconst getProj4FromCoords = (lat, lon) => {\n  const zone = getZone(lat, lon)\n  return getProj4FromZone(zone)\n}\n\nexport {\n  getEPSGCodeFromCoords,\n  getEPSGCodeFromZone,\n  getProj4FromCoords,\n  getProj4FromZone,\n  getZone,\n  transformPoint,\n  dmsToDeg\n}\n","'use strict'\n\nimport { strict as assert } from 'assert'\nimport { unit, createUnit } from 'mathjs'\nimport proj4 from 'proj4'\n\nimport { USFT_TO_METERS, USYD_TO_METERS } from './constants'\nimport * as position from './position'\n\nclass UnitConverter {\n  /**\n   *\n   * @param {object} params\n   * @param {object} params.outputMeasurementSystem The output measurementSystem to be used\n   * @param {object} [params.inputMeasurementSystem] The input measurementSystem to be used\n   * @param {object} [params.matrix] The transform matrix. If not set `parameters` must be set\n   * @param {object} [params.parameters] The transform parameters. If not set `matrix` must be set\n   * @param {object} [params.geoidHeight] The geoid height to apply. Only used when transforming using parameters.\n   */\n  constructor (params = {}) {\n    Object.assign(\n      this,\n      {\n        inputMeasurementSystem: UnitConverter.defaultInputMeasurementSystem,\n        inputZRef: 'ellipsoid', // ignored when using matrix transformation\n        outputZRef: 'geoid', // ignored when using matrix transformation\n        geoidHeight: 0\n      },\n      params\n    )\n\n    // map this.transform to this.matrix\n    if (this.transform && !this.matrix) {\n      this.matrix = this.transform\n    }\n\n    assert.equal(typeof this.inputMeasurementSystem, 'object')\n    assert.equal(typeof this.outputMeasurementSystem, 'object')\n    assert.ok(\n      ['ellipsoid', 'geoid'].indexOf(this.inputZRef) !== -1,\n      'inputZRef must be oneof \"ellipsoid\" or \"geoid\"'\n    )\n    assert.ok(\n      ['ellipsoid', 'geoid'].indexOf(this.outputZRef) !== -1,\n      'outputZRef must be oneof \"ellipsoid\" or \"geoid\"'\n    )\n\n    // expose unit for testing\n    this.unit = unit\n  }\n\n  static get defaultInputMeasurementSystem () {\n    return {\n      position: 'dd',\n      length: 'm',\n      area: 'm2',\n      volume: 'm3',\n      mass: 'tonne',\n      density: 'tonne/m3'\n    }\n  }\n\n  reverse () {\n    const params = Object.assign({}, this, {\n      inputMeasurementSystem: this.outputMeasurementSystem,\n      outputMeasurementSystem: this.inputMeasurementSystem,\n      inputZRef: this.outputZRef,\n      outputZRef: this.inputZRef\n    })\n    return new UnitConverter(params)\n  }\n\n  position (x, y, z) {\n    const { matrix, parameters } = this\n    assert.equal(\n      !!matrix || !!parameters,\n      true,\n      'To convert a position you must specify either a transform matrix or parameters'\n    )\n\n    // matrix if present takes precendence over parameters and geoidHeight\n    if (matrix && Object.keys(matrix).length > 0) {\n      return this._applyMatrixToPoint(...arguments)\n    }\n    return this._applyParametersAndGeoidToPoint(...arguments)\n  }\n\n  _applyParametersAndGeoidToPoint (x, y, z) {\n    assert.equal(\n      typeof this.parameters,\n      'object',\n      'Missing transform parameters'\n    )\n\n    let xfinal, yfinal\n    const {\n      inputMeasurementSystem,\n      outputMeasurementSystem,\n      parameters,\n      geoidHeight = 0,\n      inputZRef,\n      outputZRef\n    } = this\n\n    const inputXYUnit = this._cleanUnit(inputMeasurementSystem.position)\n    const inputZUnit = this._cleanUnit(inputMeasurementSystem.length)\n    const outputXYUnit = this._cleanUnit(outputMeasurementSystem.position)\n    const outputZUnit = this._cleanUnit(outputMeasurementSystem.length)\n    const { value: xraw } = this._parseValue(x, inputXYUnit)\n    const { value: yraw } = this._parseValue(y, inputXYUnit)\n    const { value: zraw, unit: zunit } = this._parseValue(z, inputZUnit)\n\n    if (inputXYUnit === outputXYUnit) {\n      xfinal = unit(xraw, outputXYUnit).toNumeric()\n      yfinal = unit(yraw, outputXYUnit).toNumeric()\n    } else if (inputXYUnit === 'dd' && outputXYUnit !== 'dd') {\n      // Convert from WGS84 -> LOCAL\n\n      const lon = xraw\n      const lat = yraw\n\n      // Convert from WGS84 to the specified projection\n      const inproj = 'EPSG:4326'\n      const outproj = parameters.projection.proj4\n      const coord = proj4(inproj, outproj).forward([lon, lat])\n      xfinal = coord[0]\n      yfinal = coord[1]\n    } else if (inputXYUnit !== 'dd' && outputXYUnit === 'dd') {\n      // Convert from LOCAL => WGS84\n\n      // 1. convert from WGS84 to the specified projection and apply the geoid height\n      const inproj = parameters.projection.proj4\n      const outproj = 'EPSG:4326'\n      const coord = proj4(inproj, outproj).forward([xraw, yraw])\n      xfinal = coord[0]\n      yfinal = coord[1]\n    }\n\n    // Adjust the Z\n\n    // z value should be in meters before applying the geoid height\n    const zmeter = unit(zraw, zunit)\n      .to('m')\n      .toNumeric()\n\n    // Apply the geoid height (to get the ellipsoid/orthometric height)\n    // This value is always in meters\n    const zfinalm = this._applyGeoidHeight(\n      zmeter,\n      geoidHeight,\n      inputZRef,\n      outputZRef\n    )\n\n    // Convert zfinalm to output unit\n    const zfinal = unit(zfinalm, 'm')\n      .to(outputZUnit)\n      .toNumeric()\n\n    return {\n      x: unit(xfinal, outputXYUnit),\n      y: unit(yfinal, outputXYUnit),\n      z: unit(zfinal, outputZUnit)\n    }\n  }\n\n  _applyMatrixToPoint (x, y, z) {\n    assert.equal(typeof this.matrix, 'object', 'Missing transform matrix')\n\n    let xfinal, yfinal, zfinal\n    const { inputMeasurementSystem, outputMeasurementSystem, matrix } = this\n    const { utmZone } = matrix\n\n    const inputXYUnit = this._cleanUnit(inputMeasurementSystem.position)\n    const inputZUnit = this._cleanUnit(inputMeasurementSystem.length)\n    const outputXYUnit = this._cleanUnit(outputMeasurementSystem.position)\n    const outputZUnit = this._cleanUnit(outputMeasurementSystem.length)\n    const { value: xraw } = this._parseValue(x, inputXYUnit)\n    const { value: yraw } = this._parseValue(y, inputXYUnit)\n    const { value: zraw, unit: zunit } = this._parseValue(z, inputZUnit)\n\n    if (inputXYUnit === outputXYUnit) {\n      xfinal = unit(xraw, outputXYUnit).toNumeric()\n      yfinal = unit(yraw, outputXYUnit).toNumeric()\n      zfinal = unit(zraw, zunit)\n        .to(outputZUnit)\n        .toNumeric()\n    } else if (inputXYUnit === 'dd' && outputXYUnit !== 'dd') {\n      // Convert from WGS84 -> LOCAL\n\n      // 1. z value should be in meters (and assumed to be already height above ellipsoid)\n      const zmeter = unit(zraw, zunit)\n        .to('m')\n        .toNumeric()\n      const lon = xraw\n      const lat = yraw\n\n      // 2. convert from WGS84 to UTM\n      const inproj = 'EPSG:4326'\n      const outproj = position.getProj4FromZone(utmZone)\n      const coord = proj4(inproj, outproj).forward([lon, lat])\n      const xutm = coord[0]\n      const yutm = coord[1]\n\n      // 3. convert from UTM to LOCAL\n      const { utm2local } = matrix\n      const res = position.transformPoint(utm2local, [xutm, yutm, zmeter])\n      xfinal = res.x\n      yfinal = res.y\n      zfinal = res.z\n    } else if (inputXYUnit !== 'dd' && outputXYUnit === 'dd') {\n      // Convert from LOCAL -> WGS84\n\n      // 1. convert from LOCAL to UTM\n      const { local2utm } = matrix\n      const { x: xutm, y: yutm, z: zmeter } = position.transformPoint(\n        local2utm,\n        [xraw, yraw, zraw]\n      )\n\n      // 2. convert from UTM to WGS84\n      // const inproj = position.getProj4FromCoords(lat, lon)\n      const inproj = position.getProj4FromZone(utmZone)\n      const outproj = 'EPSG:4326'\n      const coord = proj4(inproj, outproj).forward([xutm, yutm])\n      xfinal = coord[0]\n      yfinal = coord[1]\n\n      // 3. convert z to output unit\n      zfinal = unit(zmeter, 'm')\n        .to(outputZUnit)\n        .toNumeric()\n    }\n\n    return {\n      x: unit(xfinal, outputXYUnit),\n      y: unit(yfinal, outputXYUnit),\n      z: unit(zfinal, outputZUnit)\n    }\n  }\n\n  value (quantity, value) {\n    const input = this._wrapInput(quantity, value)\n    let targetUnit = this.outputMeasurementSystem[quantity]\n    targetUnit = this._cleanUnit(targetUnit)\n    return input.to(targetUnit)\n  }\n\n  _wrapInput (quantity, value) {\n    const parsed = this._parseValue(\n      value,\n      this.inputMeasurementSystem[quantity]\n    )\n    const inputUnit = parsed.unit\n    value = parsed.value\n    return unit(value, inputUnit)\n  }\n\n  _parseValue (value, defaultUnit) {\n    let unit = defaultUnit\n    // check to see if we are dealing with a string that contains units\n    if (typeof value === 'string') {\n      const parts = value.split(' ')\n      value = parseFloat(parts.shift()) // first part will always be the value\n\n      // this check allows us to support string value with no unit\n      if (parts.length) {\n        unit = parts.join('') // remaining part is the unit\n      }\n    }\n    unit = this._cleanUnit(unit)\n    return { value, unit }\n  }\n\n  _cleanUnit (unit) {\n    // mathjs unit must contain alphanumeric or / only\n    return unit.replace(/[-_]/gi, '')\n  }\n\n  _applyGeoidHeight (zmeter, geoidHeight, inputZRef, outputZRef) {\n    if (inputZRef === 'ellipsoid' && outputZRef === 'geoid') {\n      // Compute the orthometric height\n      // The formula is H = h - N, where H is orthometric height, h is ellipsoid height, and N is geoid height\n      return zmeter - geoidHeight // return the orthometric height\n    } else if (inputZRef === 'geoid' && outputZRef === 'ellipsoid') {\n      // Compute the ellipsoid height\n      // The formula is h = H + N, where H is orthometric height, h is ellipsoid height, and N is geoid height\n      return zmeter + geoidHeight // return the ellipsoid height\n    }\n    // inputZRef and outputZRef are the same so do nothing\n    return zmeter\n  }\n}\n\n// setup convenience methods for simple unit transformation\n;['length', 'area', 'volume', 'mass', 'density'].forEach(method => {\n  UnitConverter.prototype[method] = function () {\n    return this.value(method, ...arguments)\n  }\n})\n\n// setup new units ///////////////////////////////////////\n\ncreateUnit('dd')\ncreateUnit('usft', {\n  definition: `${USFT_TO_METERS} m`,\n  aliases: ['ftus']\n})\ncreateUnit('usft2', {\n  definition: `${Math.pow(USFT_TO_METERS, 2)} m2`,\n  aliases: ['ussqft', 'sqftus']\n})\ncreateUnit('usft3', {\n  definition: `${Math.pow(USFT_TO_METERS, 3)} m3`,\n  aliases: ['uscuft', 'cuftus']\n})\ncreateUnit('usyd', {\n  definition: `${USYD_TO_METERS} m`,\n  aliases: ['ydus']\n})\ncreateUnit('usyd2', {\n  definition: `${Math.pow(USYD_TO_METERS, 2)} m2`,\n  aliases: ['ussqyd', 'sqydus']\n})\ncreateUnit('usyd3', {\n  definition: `${Math.pow(USYD_TO_METERS, 3)} m3`,\n  aliases: ['uscuyd', 'cuydus']\n})\n\nexport default UnitConverter\n"],"names":["USFT_TO_METERS","USYD_TO_METERS","transformPoint","matrix","point","x","y","z","getProj4FromZone","zone","isSouth","substr","toLowerCase","Error","UnitConverter","params","Object","assign","inputMeasurementSystem","defaultInputMeasurementSystem","inputZRef","outputZRef","geoidHeight","transform","assert","equal","outputMeasurementSystem","ok","indexOf","unit","parameters","keys","length","_applyMatrixToPoint","arguments","_applyParametersAndGeoidToPoint","xfinal","yfinal","inputXYUnit","_cleanUnit","position","inputZUnit","outputXYUnit","outputZUnit","_parseValue","xraw","value","yraw","zraw","zunit","toNumeric","lon","lat","inproj","outproj","projection","proj4","coord","forward","zmeter","to","zfinalm","_applyGeoidHeight","zfinal","utmZone","xutm","yutm","utm2local","res","local2utm","quantity","input","_wrapInput","targetUnit","parsed","inputUnit","defaultUnit","parts","split","parseFloat","shift","join","replace","area","volume","mass","density","forEach","method","prototype","createUnit","definition","aliases","Math","pow"],"mappings":"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"}